<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>2nd-Order LPF — Bilinear + Prewarping (Scientific + PZ)</title>

<script src="https://cdn.jsdelivr.net/npm/mathjs@12.4.2/lib/browser/math.js"></script>
<script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>

<style>
  body { font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; color:#000; background:#fff; margin:0; padding:20px; }
  h1 { font-size:22px; text-align:center; margin-bottom:10px; }
  .container { max-width:1100px; margin:0 auto; }
  .card { background:#fafafa; border:1px solid #ccc; border-radius:8px; padding:16px 20px; margin-top:10px; }
  label { display:block; font-size:13px; margin-top:10px; }
  input,button { border:1px solid #999; border-radius:5px; padding:6px 8px; background:#fff; color:#000; width:100%; }
  button { background:#f0f0f0; cursor:pointer; margin-top:16px; }
  .row { display:flex; flex-wrap:wrap; gap:12px; }
  .col { flex:1; min-width:180px; }
  .plot { height:380px; margin-top:16px; }
  table { border-collapse:collapse; width:100%; margin-top:10px; }
  th,td { border:1px solid #ccc; padding:4px 8px; text-align:center; font-family:monospace; }
  th { background:#eee; }
</style>
</head>

<body>
<div class="container">
  <h1>Z-Domain 2nd-Order Low-Pass Filter<br/>Bilinear Transform with Prewarping</h1>

  <div class="card">
    <div class="row">
      <div class="col">
        <label>Critical frequency f<sub>c</sub> [Hz]</label>
        <input id="fc" type="number" value="1000" step="any" />
      </div>
      <div class="col">
        <label>Sampling frequency f<sub>s</sub> [Hz]</label>
        <input id="fs" type="number" value="48000" step="any" />
      </div>
      <div class="col">
        <label>Q factor</label>
        <input id="q" type="number" value="0.7071" step="any" />
      </div>
      <div class="col">
        <label>Points</label>
        <input id="n" type="number" value="501" step="1" />
      </div>
      <div class="col" style="align-self:end;">
        <button id="plotBtn">Design & Plot</button>
      </div>
    </div>

    <div id="intermediate"></div>
    <div id="mag" class="plot"></div>
    <div id="phase" class="plot"></div>
    <div id="pz" class="plot"></div>
    <div id="coeffs"></div>
  </div>
</div>

<script>
const m = math;

// --- Quadratic solver for complex roots: a*z^2 + b*z + c = 0 ---
function quadRoots(a,b,c){
  // Use numerically stable quadratic formula
  const two = m.bignumber(2);
  const bb = m.complex(b);
  const aa = m.complex(a);
  const cc = m.complex(c);
  const disc = m.subtract(m.multiply(bb,bb), m.multiply(m.multiply(4,aa),cc));
  const sqrtDisc = m.sqrt(disc);
  // Choose sign to avoid cancellation
  const denom1 = m.multiply(2,aa);
  // If Re(b) >= 0, use -b - sqrt(D); else -b + sqrt(D)
  const bRe = m.re(bb);
  const num1 = (bRe >= 0) ? m.subtract(m.unaryMinus(bb), sqrtDisc)
                          : m.add(m.unaryMinus(bb), sqrtDisc);
  const z1 = m.divide(num1, denom1);
  const z2 = m.divide(cc, m.multiply(aa, z1)); // Viète: z2 = c/(a*z1)
  return [z1, z2];
}

function bilinearLPF(fc, fs, Q){
  if(fc >= fs/2) throw new Error("fc must be below Nyquist.");
  const Oc = 2*fs * Math.tan(Math.PI*fc/fs);  // prewarped analog cutoff
  const K = 2*fs;

  // Analog prototype coefficients
  const a0 = 1;
  const a1 = Oc / Q;
  const a2 = Oc * Oc;
  const b0a = 0, b1a = 0, b2a = Oc * Oc;

  // Bilinear transform expansion
  const Ad0 = a0*K*K + a1*K + a2;
  const Ad1 = -2*a0*K*K + 2*a2;
  const Ad2 = a0*K*K - a1*K + a2;

  const Bd0 = b2a;
  const Bd1 = 2*b2a;
  const Bd2 = b2a;

  // Normalize so a[0] = 1
  const b = [ Bd0/Ad0, Bd1/Ad0, Bd2/Ad0 ];
  const a = [ 1, Ad1/Ad0, Ad2/Ad0 ];

  return { b, a, Oc, K, a0, a1, a2, Ad0, Ad1, Ad2 };
}

function logspace(a,b,n){
  const step = (b-a)/(n-1), arr=[];
  for(let i=0;i<n;i++) arr.push(Math.pow(10,a+i*step));
  return arr;
}

function computeResponse(b,a,fs,fc,n=501){
  const halfDecades = 1.5;
  const fmin = fc * Math.pow(10,-halfDecades);
  const fmax = Math.min(fc * Math.pow(10,halfDecades), fs/2 * 0.999);
  const freqs = logspace(Math.log10(fmin), Math.log10(fmax), n);
  const magdB=[], phaseDeg=[];
  for(const f of freqs){
    const w = 2*Math.PI*f/fs;
    const z = m.exp(m.multiply(m.complex(0,-1), w)); // e^{-j*w}
    const z2 = m.pow(z, 2);
    const num = m.add(m.add(m.multiply(b[0], 1), m.multiply(b[1], z)), m.multiply(b[2], z2));
    const den = m.add(1, m.add(m.multiply(a[1], z), m.multiply(a[2], z2)));
    const H = m.divide(num, den);
    magdB.push(20*Math.log10(m.abs(H)));
    phaseDeg.push(m.arg(H)*180/Math.PI);
  }
  return { freqs, magdB, phaseDeg };
}

function plot(){
  const fc = parseFloat(fcInput.value);
  const fs = parseFloat(fsInput.value);
  const Q  = parseFloat(qInput.value);
  const n  = parseInt(nInput.value);
  try {
    const {b,a,Oc,K,a0,a1,a2,Ad0,Ad1,Ad2} = bilinearLPF(fc,fs,Q);
    const {freqs,magdB,phaseDeg} = computeResponse(b,a,fs,fc,n);

    // Intermediate results
    document.getElementById('intermediate').innerHTML = `
      <h3>Intermediate Calculations</h3>
      <table>
        <tr><th>Quantity</th><th>Expression</th><th>Value</th></tr>
        <tr><td>Prewarped Ω<sub>c</sub></td><td>2 f<sub>s</sub> tan(π f<sub>c</sub>/f<sub>s</sub>)</td><td>${Oc.toExponential(6)}</td></tr>
<!--        <tr><td>K</td><td>2 f<sub>s</sub></td><td>${K.toFixed(3)}</td></tr>
        <tr><td>a₀</td><td>1</td><td>${a0}</td></tr>
        <tr><td>a₁</td><td>Ω<sub>c</sub>/Q</td><td>${a1.toExponential(6)}</td></tr>
        <tr><td>a₂</td><td>Ω<sub>c</sub>²</td><td>${a2.toExponential(6)}</td></tr>
        <tr><td>A<sub>d0</sub></td><td>a₀K² + a₁K + a₂</td><td>${Ad0.toExponential(6)}</td></tr>-->
      </table>`;

    // Coefficients
    document.getElementById('coeffs').innerHTML = `
      <h3>Digital Filter Coefficients</h3>
      <table>
        <tr><th>Coefficient</th><th>Value</th></tr>
        <tr><td>b₀</td><td>${b[0].toPrecision(9)}</td></tr>
        <tr><td>b₁</td><td>${b[1].toPrecision(9)}</td></tr>
        <tr><td>b₂</td><td>${b[2].toPrecision(9)}</td></tr>
        <tr><td>a₀</td><td>1.00000000</td></tr>
        <tr><td>a₁</td><td>${a[1].toPrecision(9)}</td></tr>
        <tr><td>a₂</td><td>${a[2].toPrecision(9)}</td></tr>
      </table>`;

    // Plot settings (B/W + grid)
    const lineFc = { type:'line', x0:fc, x1:fc, y0:-200, y1:10, xref:'x', yref:'y', line:{ dash:'dash', color:'black' } };
    const lineNyq = { type:'line', x0:fs/2, x1:fs/2, y0:-200, y1:10, xref:'x', yref:'y', line:{ dash:'dot', color:'gray' } };

    Plotly.newPlot('mag', [{x:freqs,y:magdB,mode:'lines',line:{color:'black'}}],
      {title:'Magnitude |H(f)| [dB]', xaxis:{type:'log', title:'Frequency [Hz]', showgrid:true, gridcolor:'#ccc'},
       yaxis:{title:'Magnitude [dB]', showgrid:true, gridcolor:'#ccc'}, shapes:[lineFc,lineNyq],
       plot_bgcolor:'#fff', paper_bgcolor:'#fff', font:{color:'#000'}, margin:{t:40,r:20,b:60,l:60}},
      {responsive:true});

    Plotly.newPlot('phase', [{x:freqs,y:phaseDeg,mode:'lines',line:{color:'black'}}],
      {title:'Phase ∠H(f) [degrees]', xaxis:{type:'log', title:'Frequency [Hz]', showgrid:true, gridcolor:'#ccc'},
       yaxis:{title:'Phase [°]', showgrid:true, gridcolor:'#ccc'}, shapes:[lineFc,lineNyq],
       plot_bgcolor:'#fff', paper_bgcolor:'#fff', font:{color:'#000'}, margin:{t:40,r:20,b:60,l:60}},
      {responsive:true});

    // --- Pole–Zero diagram via quadratic roots ---
    // Zeros: b0*z^2 + b1*z + b2 = 0
    const [z0, z1] = quadRoots(b[0], b[1], b[2]);
    // Poles: z^2 + a1*z + a2 = 0
    const [p0, p1] = quadRoots(1, a[1], a[2]);

    const zeroX = [m.re(z0), m.re(z1)];
    const zeroY = [m.im(z0), m.im(z1)];
    const poleX = [m.re(p0), m.re(p1)];
    const poleY = [m.im(p0), m.im(p1)];

    // Unit circle
    const theta = [];
    for(let t=0; t<=2*Math.PI; t+=0.01){ theta.push(t); }
    const unitX = theta.map(t => Math.cos(t));
    const unitY = theta.map(t => Math.sin(t));

    const pzData = [
      {x: unitX, y: unitY, mode:'lines', line:{color:'#aaa'}, name:'Unit circle'},
      {x: zeroX, y: zeroY, mode:'markers', marker:{color:'blue', symbol:'circle-open', size:10}, name:'Zeros'},
      {x: poleX, y: poleY, mode:'markers', marker:{color:'red', symbol:'x', size:10}, name:'Poles'}
    ];

    Plotly.newPlot('pz', pzData, {
      title:'Pole–Zero Diagram (z-plane)',
      xaxis:{title:'Re{z}', zeroline:true, showgrid:true, range:[-1.5,1.5]},
      yaxis:{title:'Im{z}', zeroline:true, showgrid:true, range:[-1.5,1.5], scaleanchor:'x', scaleratio:1},
      plot_bgcolor:'#fff', paper_bgcolor:'#fff', font:{color:'#000'}, margin:{t:40,r:20,b:60,l:60},
      showlegend:true
    });

  } catch(err){
    alert(err.message);
  }
}

const fcInput=document.getElementById('fc');
const fsInput=document.getElementById('fs');
const qInput=document.getElementById('q');
const nInput=document.getElementById('n');
document.getElementById('plotBtn').addEventListener('click',plot);
plot();
</script>
</body>
</html>
