<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <title>GPS DSP Demo</title>
  <style>
    body { font-family: sans-serif; margin: 0; padding: 0; }
    canvas { border: 1px solid black; margin: 5px; display: block; }
    .container {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
    }
    #map, #corr {
      flex: 1 1 45%;
      min-width: 250px;
      max-width: 400px;   /* cap individual top plots */
      aspect-ratio: 1 / 1;
    }
    #periodic {
      width: 95%;
      max-width: 800px;   /* sum of top plots */
      margin: auto;
      aspect-ratio: 3 / 1;
    }
  </style>
</head>
<body>
  <h2 style="padding:10px;">GPS Trilateration &amp; DSP Cross-Correlation Demo</h2>
  <p style="padding:10px;">
    Click/tap on the map to move the receiver.  
    Right: instantaneous correlation peaks.  
    Bottom: periodic cross-correlation outputs with grid/ticks.
  </p>

  <div class="container">
    <canvas id="map" width="400" height="400"></canvas>
    <canvas id="corr" width="400" height="400"></canvas>
  </div>
  <div>
    <canvas id="periodic" width="800" height="267"></canvas>
  </div>

  <script>
    const map = document.getElementById("map");
    const corr = document.getElementById("corr");
    const periodic = document.getElementById("periodic");
    const ctxMap = map.getContext("2d");
    const ctxCorr = corr.getContext("2d");
    const ctxPer = periodic.getContext("2d");

    const sats = [
      {x: 50, y: 50, color: "red", label: "Sat 1"},
      {x: 350, y: 50, color: "green", label: "Sat 2"},
      {x: 50, y: 350, color: "blue", label: "Sat 3"},
      {x: 350, y: 350, color: "magenta", label: "Sat 4"}
    ];
    let receiver = {x: 200, y: 200};

    function distance(a, b) {
      return Math.sqrt((a.x - b.x)**2 + (a.y - b.y)**2);
    }

    function resizeCanvas(canvas) {
      canvas.width = canvas.clientWidth;
      canvas.height = canvas.clientHeight;
    }
    function resizeAll() {
      [map, corr, periodic].forEach(resizeCanvas);
      redraw();
    }

    function getFontSize() {
      const calc = Math.round(window.innerWidth/80);
      return Math.min(18, Math.max(10, calc)); 
    }

    // Map
    function drawMap() {
      ctxMap.clearRect(0,0,map.width,map.height);
      const scaleX = map.width/400, scaleY = map.height/400;
      ctxMap.font = `${getFontSize()}px sans-serif`;
      sats.forEach(s => {
        ctxMap.fillStyle = s.color;
        ctxMap.beginPath();
        ctxMap.arc(s.x*scaleX, s.y*scaleY, 8*scaleX, 0, 2*Math.PI);
        ctxMap.fill();
        ctxMap.fillText(s.label, s.x*scaleX+12, s.y*scaleY-5);
      });
      ctxMap.fillStyle = "black";
      ctxMap.beginPath();
      ctxMap.arc(receiver.x*scaleX, receiver.y*scaleY, 6*scaleX, 0, 2*Math.PI);
      ctxMap.fill();
      ctxMap.fillText("Rx", receiver.x*scaleX+12, receiver.y*scaleY-5);
      sats.forEach(s => {
        let d = distance(receiver, s);
        ctxMap.strokeStyle = s.color;
        ctxMap.beginPath();
        ctxMap.arc(s.x*scaleX, s.y*scaleY, d*scaleX, 0, 2*Math.PI);
        ctxMap.stroke();
      });
    }

    // Correlation peaks with rotated labels
    function drawCorr() {
      ctxCorr.clearRect(0,0,corr.width,corr.height);
      ctxCorr.font = `${getFontSize()}px sans-serif`;
      ctxCorr.strokeStyle = "black";
      ctxCorr.strokeRect(40,20,corr.width-80,corr.height-40);
      ctxCorr.fillText("Correlation Peaks", corr.width/2 - 80, 15);
      sats.forEach((s,i) => {
        let d = distance(receiver, s);
        let delay = d / 2;
        let usableW = corr.width - 80;
        let x = 40 + (delay % usableW);
        let y = 60 + i*(corr.height-120)/4;
        ctxCorr.strokeStyle = s.color;
        ctxCorr.beginPath();
        ctxCorr.moveTo(x, y-20);
        ctxCorr.lineTo(x, y+20);
        ctxCorr.stroke();

        // rotated satellite label
        ctxCorr.save();
        ctxCorr.translate(20, y); 
        ctxCorr.rotate(-Math.PI/2);
        ctxCorr.fillStyle = s.color;
        ctxCorr.fillText(s.label, 0, 0);
        ctxCorr.restore();
      });
    }

    // Periodic plot with ticks/grid
    function drawPeriodic() {
      ctxPer.clearRect(0,0,periodic.width,periodic.height);
      ctxPer.font = `${getFontSize()}px sans-serif`;
      const usableW = periodic.width - 80;
      const usableH = periodic.height - 80;
      const left = 40, bottom = periodic.height-40;

      // grid lines
      ctxPer.strokeStyle = "#ddd";
      ctxPer.beginPath();
      for (let i=0; i<=8; i++) {
        let x = left + i*(usableW/8);
        ctxPer.moveTo(x, 20);
        ctxPer.lineTo(x, bottom);
      }
      for (let j=0; j<=4; j++) {
        let y = bottom - j*(usableH/4);
        ctxPer.moveTo(left, y);
        ctxPer.lineTo(left+usableW, y);
      }
      ctxPer.stroke();

      // frame
      ctxPer.strokeStyle = "black";
      ctxPer.strokeRect(left,20,usableW,usableH);

      // axis labels
      ctxPer.fillStyle = "black";
      ctxPer.fillText("Periodic Cross-Correlation (excerpt)", periodic.width/2 - 140, 15);
      ctxPer.fillText("Code Phase (chips/lag)", periodic.width/2 - 50, periodic.height - 10);
      ctxPer.save();
      ctxPer.translate(15, periodic.height/2);
      ctxPer.rotate(-Math.PI/2);
//      ctxPer.fillText("Correlation Value", -40, 10);
      ctxPer.restore();

      // ticks (X)
      ctxPer.fillStyle = "black";
      for (let i=0; i<=8; i++) {
        let x = left + i*(usableW/8);
        ctxPer.beginPath();
        ctxPer.moveTo(x, bottom);
        ctxPer.lineTo(x, bottom+0);
        ctxPer.stroke();
        ctxPer.fillText(i*4, x-5, bottom+0);
      }
      // ticks (Y)
      for (let j=0; j<=4; j++) {
        let y = bottom - j*(usableH/4);
        ctxPer.beginPath();
        ctxPer.moveTo(left-5, y);
        ctxPer.lineTo(left, y);
			  ctxPer.stroke();
	if (j>=1)
	    ctxPer.fillText(((j*16-32)/32).toString(), left-30, y+5);
      }

      // dummy correlations
	sats.forEach((s,i) => {
	const prnlength = 48;
        const prn = Array.from({length:prnlength}, ()=> Math.random()>0.5?1:-1);
        const delay = Math.floor(distance(receiver, s)/10);
        const period = prn.length;
        const received = new Array(4*period+delay+period).fill(0);
        for(let cycle=0; cycle<4; cycle++){
          for(let k=0;k<prn.length;k++){
            if(cycle*period + k + delay < received.length){
              received[cycle*period + k + delay] = prn[k];
            }
          }
        }
        const corrVals = [];
        for(let tau=0;tau<4*period; tau++){
          let sum=0;
          for(let k=0;k<prn.length;k++){
            if(k+tau < received.length) sum += prn[k]*received[k+tau];
          }
          corrVals.push(sum);
        }
        ctxPer.strokeStyle = s.color;
        ctxPer.beginPath();
        corrVals.forEach((val,j)=>{
          let x = left + j*(usableW/corrVals.length);
            let y = bottom - (val+prnlength)/(prnlength*2)*usableH;
          if(j===0) ctxPer.moveTo(x,y);
          else ctxPer.lineTo(x,y);
        });
        ctxPer.stroke();
      });
    }

    function redraw() {
      drawMap();
      drawCorr();
      drawPeriodic();
    }

    map.addEventListener("click", (e) => {
      const rect = map.getBoundingClientRect();
      receiver.x = (e.clientX - rect.left) * 400/map.width;
      receiver.y = (e.clientY - rect.top) * 400/map.height;
      redraw();
    });

    window.addEventListener('resize', resizeAll);
    resizeAll();
  </script>


</body></html>
